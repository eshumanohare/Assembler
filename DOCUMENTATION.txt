***************************************************ASSUMPTIONS****************************************************************
1.Not implemented START and END
1.If you want to add comment, you can do so by adding '<' sign followed by the comment you want to add.
2.We dont need to declare any variable in our code.Every variable used will be automatically allocated memory
3.Literals can be used only by commands:BRZ,BRN,BRP
4.To declare a literal the name should be followed by ':',without any space.
5.CLA and STP commands should not be followed by any other statement
6.Our assembler is case sensitive.Hence,all the code should preferably be in capitals


***************************************************INSTRUCTION TO RUN*********************************************************

write your assembly language code in a file name asm_code.txt
Copy this file to the folder containg the .py file
Run .py file
You will get the final output in a file named object_code.txt in the same folder containg the initial file

***************************************************WORK FLOW******************************************************************

First we read our assembly code and store each line in a touple named ac
we initialise tables and create a dictionary(from assembly to machine one)
FIRST PASS:
	We read this file line by line
	For each line we store each word in a touple named words
	we proceed by checking the number of words in each line 
	while reading it keeps on checking for errors and add to the errors file(if any)
	It creates and add on to the literal table and symbol table
We give address to the symbols used(addresses after the last line of the code is allocated to the symbols)
If there are no errors in the file We proceed to second pass 
we create a helper function(giveval) which gives the binary value of the address after finding them from the tables created
SECOND PASS:
	we read the file line by line
	We keep on converting the code to the machine code using the dictionary we created before
	we do not convert a literal to the machine code(we just replace it with the address where it is initialised)
At the end we print this final file and store this machine code to a file named "object_code.txt"


***************************************************ERROR REPORTING/HANDLING***************************************************

All the errors with the line where it is occuring,and the number of errors are stored and print at once after the first pass(if any)


1. Required amounts of operands are not provided.
2. Undefined Label.
3. CLA or STP is followed by a preceding code.
4. Opcode name used as a label.
5. Declaring a label more than once.
6. Invalid Syntax(includes: bigger length of code,trying to declare a variable,opcode with different name,use of invalid opcode,etc)



***************************************************ASSEMBLER OUTPUT***********************************************************
Navigate to the directory where the input file is present. The Assembler generates object_code.txt file:

It contains the machine code generated by the Assembler, i.e. the 12 bit code in binary number. 
If errors are found in the asm_code.txt file, then this file would not be created
